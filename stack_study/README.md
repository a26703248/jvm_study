
## 虛擬機棧區域（JVM Stack）
定義:棧可透過數組或鏈表實作,但不可通過索引訪問元素,只能透過出棧(push)和入棧(pop)操作
### 記憶體相關錯誤
#### StackOverflowError
發生情況:
當 Java 棧為固定大小時，若執行緒請求使用的棧(Stack)超過Java 虛擬機允許的棧(Stack)大小則會發生棧溢出錯誤，例:遞迴次數過多
#### OutOfMemoryError
發生情況:
當 Java 棧為動態大小時，若執行緒無法請求到可使用的棧(Stack)空間則會發生記憶體洩漏錯誤，例:陣列長度超過記憶體大小

### 棧(Stack)系統預設大小
![stack_args](images/stack_args.png)

### 棧偵(Stack frame)結構
* 區域變數表(Local Variables)
* 執行操作數棧(Operand Stack)
* 方法回傳位址(Return Address)
* 動態連結(Dynamic Linking)
* 其他回傳資訊  
![stack_struct](images/stack_struct.png)
### 區域(本地)變數表(Local Variables)
* 可儲存基本類型、物件類型及returnAddress類型
* 因數據類型儲存在棧內故而無執行緒安全問題
* 區域變數表大小是在編譯時期決定好的並保存在Code屬性中的maximum local variable,運行時部會更改
* 區域變數表基本的储存單位為 Slot
* 每一32位元占用1個 Slot(包括ReturnAddress類型),而byte、short、char會被轉換成int储存,boolean相同會被轉換成int储存,0代表false,1代表true,64位元占用2個Slot(包括double、long類型)
* Slot是可重複利用的
#### 物件中的靜態變數與方法內的區域變數差別
在使用變數時,物件中的靜態變數都經過默認初始化(Linking的prepare階段)可直接使用,方法內的區域變數則不會初始化,需顯式給值否則編譯時不會通過
### 執行操作數棧(Operand Stack)
執行操作數棧為LIFO(後進先出)模式,也可稱之為表達式棧(Expression Stack),再根據方法執行時依照執行指令往棧內寫入或提取數據,及出棧(push)和入棧(pop)
### 棧頂緩存技術
因執行方法都儲存至記憶體中導致記憶體頻繁的讀/寫,HotSpot JVM 提出了棧頂緩存技術,將棧偵頂部緩存至CPU寄存器中來減少記憶體頻繁讀寫次數,提高執行引擎效率
### 動態鏈結
在大部分程式碼在執行時都必須訪問常量池，每個栈偵內都保留一個指向運行時常量池中的該栈偵所屬方法的參考，為了維持當前方法能夠完成動態鏈結。  
所有變數及方法引用都作為符號引用(Symbolic Reference)保存在 class 文件的常量池內，例:描述一個方法調用了另一個方法時，就是通過常量池內指向方法得符號引用表示那麼動態鏈結得作用就是為了這些符號引用轉換為調用方法的直接引用

## 方法調用
靜態鏈結:   
當一個class文件被JVM 架載進記憶體中，如果被呼叫的目標方法是可以在編譯時期可知的且運行期間保持不變時，此時呼叫方法的符號引用會改為直接引用的過程稱為靜態鏈結
早期綁定(invokespecial):   
在編譯時期可知的且運行期間保持不變時，對應到靜態鏈結

動態鏈結:   
如果被調用方法在編譯時期無法得知且無法確定下來，只能使用符號引用轉換在運行期間具備動態性則稱為動態鏈結
晚期綁定(invokevisual):   
在編譯時期無法得知且無法確定下來，只能使用符號引用轉換，對應到靜態鏈結

隨著高階語言的出現，物件導向語言越來越多，盡管撰寫風格不相同但都保持著一個共同的特性，那就是支持封裝、繼承和多型等特性，都具有多型特性那就有晚期綁定與早期綁定方式。   
Java 中任何一個方法都具備虛函數特徵，相當於C++中的虛函數(C++中需以visual關鍵是顯示指定)，若不希望有需函數特性則需使用final關鍵字

### 虛方法與非虛方法
非虛方法定義:   
在編譯時期確定下來呼叫方法的最終(final)，在運行時不可變動稱為非虛方法，例:靜態方法、私有方法、final方法、建構子、super方法，其餘皆是虛方法

虛擬機中提供的普通指令:   
invokestatic: 呼叫靜態方法，解析階段確定最終方法
invokevisual: 呼叫<init>方，私有方法、父類方法，解析階段確定最終方法
invokespecial: 呼叫所有虛方法
invokeinterface: 呼叫介面方法

動態呼叫指令:   
invokedynamic(JDK1.7): 動態解析呼叫方法並執行

虛擬機中提供的四個普通指令，在執行時不可人為干預，而invokedynamic指令則是在執行時確定下來的最終方法，其中invokestatic、invokespecial及final 關鍵字外其餘皆為虛方法

### 方法呼叫:解析與派發

### 方法位址返回
