
## 虛擬機棧區域（JVM Stack）
定義:棧可透過數組或鏈表實作,但不可通過索引訪問元素,只能透過出棧(push)和入棧(pop)操作
### 記憶體相關錯誤
#### StackOverflowError
發生情況:
當 Java 棧為固定大小時，若執行緒請求使用的棧(Stack)超過Java 虛擬機允許的棧(Stack)大小則會發生棧溢出錯誤，例:遞迴次數過多
#### OutOfMemoryError
發生情況:
當 Java 棧為動態大小時，若執行緒無法請求到可使用的棧(Stack)空間則會發生記憶體洩漏錯誤，例:陣列長度超過記憶體大小

### 棧(Stack)系統預設大小
![stack_args](images/stack_args.png)

### 棧偵(Stack frame)結構
* 區域變數表(Local Variables)
* 執行操作數棧(Operand Stack)
* 方法回傳位址(Return Address)
* 動態連結(Dynamic Linking)
* 其他回傳資訊  
![stack_struct](images/stack_struct.png)
### 區域(本地)變數表(Local Variables)
* 可儲存基本類型、物件類型及returnAddress類型
* 因數據類型儲存在棧內故而無執行緒安全問題
* 區域變數表大小是在編譯時期決定好的並保存在Code屬性中的maximum local variable,運行時部會更改
* 區域變數表基本的储存單位為 Slot
* 每一32位元占用1個 Slot(包括ReturnAddress類型),而byte、short、char會被轉換成int储存,boolean相同會被轉換成int储存,0代表false,1代表true,64位元占用2個Slot(包括double、long類型)
* Slot是可重複利用的
#### 物件中的靜態變數與方法內的區域變數差別
在使用變數時,物件中的靜態變數都經過默認初始化(Linking的prepare階段)可直接使用,方法內的區域變數則不會初始化,需顯式給值否則編譯時不會通過
### 執行操作數棧(Operand Stack)
執行操作數棧為LIFO(後進先出)模式,也可稱之為表達式棧(Expression Stack),再根據方法執行時依照執行指令往棧內寫入或提取數據,及出棧(push)和入棧(pop)
### 棧頂緩存技術
因執行方法都儲存至記憶體中導致記憶體頻繁的讀/寫,HotSpot JVM 提出了棧頂緩存技術,將棧偵頂部緩存至CPU寄存器中來減少記憶體頻繁讀寫次數,提高執行引擎效率
### 動態鏈結
在大部分程式碼在執行時都必須訪問常量池，每個栈偵內都保留一個指向運行時常量池中的該栈偵所屬方法的參考，為了維持當前方法能夠完成動態鏈結。  
所有變數及方法引用都作為符號引用(Symbolic Reference)保存在 class 文件的常量池內，例:描述一個方法調用了另一個方法時，就是通過常量池內指向方法得符號引用表示那麼動態鏈結得作用就是為了這些符號引用轉換為調用方法的直接引用

## 方法調用
靜態鏈結:   
當一個class文件被JVM 架載進記憶體中，如果被呼叫的目標方法是可以在編譯時期可知的且運行期間保持不變時，此時呼叫方法的符號引用會改為直接引用的過程稱為靜態鏈結
早期綁定(invokespecial):   
在編譯時期可知的且運行期間保持不變時，對應到靜態鏈結

動態鏈結:   
如果被調用方法在編譯時期無法得知且無法確定下來，只能使用符號引用轉換在運行期間具備動態性則稱為動態鏈結
晚期綁定(invokevisual):   
在編譯時期無法得知且無法確定下來，只能使用符號引用轉換，對應到靜態鏈結

隨著高階語言的出現，物件導向語言越來越多，盡管撰寫風格不相同但都保持著一個共同的特性，那就是支持封裝、繼承和多型等特性，都具有多型特性那就有晚期綁定與早期綁定方式。   
Java 中任何一個方法都具備虛函數特徵，相當於C++中的虛函數(C++中需以visual關鍵是顯示指定)，若不希望有需函數特性則需使用final關鍵字

### 虛方法與非虛方法
非虛方法定義:   
在編譯時期確定下來呼叫方法的最終(final)，在運行時不可變動稱為非虛方法，例:靜態方法、私有方法、final方法、建構子、super方法，其餘皆是虛方法

虛擬機中提供的普通指令:   
invokestatic: 呼叫靜態方法，解析階段確定最終方法
invokevisual: 呼叫<init>方，私有方法、父類方法，解析階段確定最終方法
invokespecial: 呼叫所有虛方法
invokeinterface: 呼叫介面方法

動態呼叫指令:   
invokedynamic(JDK1.7): 動態解析呼叫方法並執行

虛擬機中提供的四個普通指令，在執行時不可人為干預，而invokedynamic指令則是在執行時確定下來的最終方法，其中invokestatic、invokespecial及final 關鍵字外其餘皆為虛方法

### Java 方法複寫本質
1. 尋找操作數栈頂的第一個元素物件的實例
2. 如果尋找過程中符合描述符合簡單名稱的方法，繼續驗證方法權限，如果通過則返回方法，在尋找過程都不通過程返回IllegalAccessError 錯誤
3. 按照繼承關係由下往上依序以第2步驟做查找及驗證
4. 始終無尋找成功則返回 java.land.AbstractMethodError錯誤

#### IllegalAccessError 介紹
在訪問或修改一個方法當前無訪問權限，通常編譯時期異常，若發生在運行時期，則說明發生類別版本不兼容的改變

### 虛方法表
因頻繁使用動態分派，每次在分派時都需重新查找方法元數據導致影響效能，因此為了提高效能，JVM在方法區內建立需方法表(visual method table)使用索引替換查找
1. 每個類別都有一個虛方法表指向方法入口
2. 需方法表會在類別加載的鏈結階段被創建及初始化，類別的變數初始化完成後JVM也會把方法表給初始化完成

### 方法返回位址
1. 儲存該方法PC寄存器的值(下一個指令的位址)
2. 一個方法結束分為兩種
   * 正常執行完成退出
   * 拋出異常非正常退出
3. 無論是哪種退出方式都需返回該方法被呼叫的位置，正常退出時則返回PC計數器的值即呼叫該方法的下一條執行指令，而異常結束則通過異常表來確定，栈偵內通常部會保存這類訊息
4. 正常退出及異常退出差別在於，異常退出出栈時不會給頂層返回任何值

#### JVM Return 指令
byte、boolean、char、short、int 都使用 ireturn   
long使用 lreturn、double使用 dreturn、float使用 freturn、參考類型使用 areturn   
void、介面方法、建構子、類別方法都使用 return

#### 異常退出
執行時期發生異常且未處理(在本方法內為搜尋異常表內為匹配到異常處理器)，導致方法退出稱為異常完成出口。   
方法執行過程中拋出異常的處理會記錄在異常處理表內，方便發生異常時找到異常處理的程式碼


### 附加訊息
栈偵中允許攜帶一些與Java虛擬機實作相關的附加訊息，例:對效能優化訊息調試得訊息